#include <bits/stdc++.h>

using namespace std;

class Solution {
private:
  int objective;
  vector<pair<int, int>> scheduled_links;

  void computeObjective() {
    
  }
  
public:
  void insert(Solution &og, int ch, int link) {
    
  }

  int getObjective() {
    return objective;
  }

  void setObjective(int ob) {
    objective = ob;
  }

  void setScheduling(const vector<pair<int, int>> &scheduled_links) {
    this->scheduled_links = scheduled_links;
    computeObjective();
  }

  vector<pair<int, int>> getScheduling() {
    return scheduled_links;
  }

  friend bool operator<(const Solution &o1, const Solution &o2);
  
  friend bool operator>(const Solution &o1, const Solution &o2);

  friend Solution& operator=(const Solution &o1);
};


bool operator<(const Solution &o1, const Solution &o2) {
  return o1.objective < o2.objective;
}

bool operator>(const Solution &o1, const Solution &o2) {
  return o1.objective > o2.objective;
}

Solution &Solution::operator=(const Solution &o1) {

}

int B[] = {20, 40, 80, 160};
vector<int> channels{25, 42, 43, 44, 45};
deque<int> links;
Solution S;
int L;

int objective_function() {
  
  return 0;
}

void updateChannels(const Solution &sol) {

}

void split(Solution &dest, const Solution &src, int ch) {

}

void decideBest(Solution &f, const Solution &u, const Solution &v) {
  if (u > v) {
    
  }
  //vector<pair<int, int>> seila = (u > v) ? u.getScheduling() : v.getScheduling();
  //f.setScheduling(u > v ? u.getScheduling() : v.getScheduling());
}

int whichBw(int ch) {
  if (ch >= 26 && ch <= 37)
    return 40;
  else if (ch >= 38  && ch <= 43)
    return 80;
  else if (ch == 44 || ch == 45)
    return 160;
  
  return 20;
}

int main() {
  srand(time(NULL));
  //-----------------------
  //scanf("%d", &L);
  L = 0;

  for (int i = 1; i <= L; i++) {
    links.emplace_back(i);
  }

  while (!links.empty()) {
    int idx = rand()%(links.size());
    int link = links[idx];

    Solution S_o, S_t;
    //-------------
    for (int ch : channels) {
      S_o.insert(S, ch, link);
      if (whichBw(ch) > 20) {
	split(S_t, S_o, ch);
      }
      decideBest(S, S_o, S_t);
    }
    updateChannels(S);
    //-------------
    swap(links[idx], links.back());
    links.pop_back();
  }
  return 0;
}
